########################################################################
# Many of the tests in this script might seem silly. That is okay.
#
# Any time you are preparing to fix an engine bug, consider adding a
# test that demonstrates the bug FIRST before you fix the bug.

include, plotscr.hsd

########################################################################

define constant(1, default wait)

global variable(100, menu item script global)
global variable(101, timer global)
global variable(102, timer global will become)
global variable(103, battle script sequence)
global variable(104, menu close global)

#string 0 = error messages
#string 1 = temporary misc
#string 10 = error message arg
#string 11 = asserts
define constant(11, assert expression string)

########################################################################

plotscript, run all tests, begin
  suspend player
  seed random(4444)
  math tests
  hero tests
  menu tests
  textbox tests
  battle tests
  timer tests
  game over
end

########################################################################

script, w, ticks=default wait, begin
  wait(ticks)
  _checkpoint
end

script, crash, begin
  if(string length(10) >> 0) then(
    $0+"("
    concatenate strings(0, 10)
    $0+")"
  )
  show text box(1)
  trace(0)
  w(25)
  game over
end

script, assert failure, begin
  trace(assert expression string)
  crash
end

########################################################################

script, math tests, begin
  variable(n)
  n := 10
  $0="math tests"
  if(abs(-10) <> n) then(crash)
  if(abs(15) <> n + 5) then(crash)
end

########################################################################

script, hero tests, begin
  hero caterpillar tests
end

## Party management
#delete hero (who)
#find hero (who)
#hero by rank (where)
#hero by slot (where)
#rank in caterpillar (who)
#get hero name (ID, hero)
#set hero name (ID, hero)
#lock hero (who)
#unlock hero (who)
#swap in hero (who)
#swap out hero (who)

## caterpillar
#check hero wall (who,direction)
#get hero speed (who)
#hero direction (who)
#hero frame (who)
#hero is walking (who)
#hero pixel X (who)
#hero pixel Y (who)
#hero X (who)
#hero Y (who)
#put hero (who, x, y)
#suspend hero walls
#resume hero walls
#set hero frame (who, frame)
#set hero position (who, x, y)
#set hero speed (who, speed)
#set hero z (who, z)
#walk hero to x (who,x)
#walk hero to y (who,x)

## spell lists
#can learn spell (hero,attack)
#forget spell (hero,attack)
#knows spell (hero,attack)
#read spell (hero,list,slot)
#teach spell (hero,attack)
#write spell (hero,list,slot,attack)

## Equipment
#check equipment (hero,slot)
#equip where (hero,item)
#force equip (hero,slot,item)
#get default weapon (hero)
#set default weapon (hero,item)
#unequip (hero,slot)

## Exp and Levels
#get hero level (who)
#set hero level (who, level, forgetspells)
#give experience (hero,amount)
#hero levelled (who)
#set dead heroes gain experience (state)
#spells learned (hero,number)
#spells learnt (hero,number)
#experience to level (level)
#experience to next level (who)
#get level cap
#set level cap (cap)
#set experience (who, experience, allowforget)
#total experience (who)
#update level up learning(who, allowforget)

## Stats
#get hero stat (who,stat,type)
#set hero stat (who,stat,value,type)
#get hero stat cap (stat)
#set capped hero stat (who,stat,value,type)
#get level MP (who, mp level slot)
#set level MP (who, mp level slot, new value)

## Appearance
#get hero palette (who,type)
#get hero picture (who,type)
#reset hero palette (who,type)
#reset hero picture (who,type)
#set hero palette (who,palette,type)
#set hero picture (who,picture,type)

## Misc
#hero base elemental resist as int (who, element)
#hero total elemental resist as int (who, element)
#set hero base elemental resist (who, element, percent)

script, hero caterpillar tests, begin
  $0="hero tests"
  add hero(1)
  add hero(2)
  walk hero(me, north, 3) # hit wall
  wait for hero(me), w
  walk hero(me, west, 2)
  wait for hero(me), w
  walk hero(me, south, 2)
  wait for hero(me), w
  walk hero(me, east, 2)
  wait for hero(me), w
  walk hero # default args
  wait for hero(me), w
  walk hero(me, east, 3)
  wait for hero(me), w
  add hero(3)
  w
  suspend caterpillar
  variable(i)
  for(i, 0, 3) do(
    walk hero(i, south, 1)
    wait for hero(i), w
    set hero direction(i, west)
    walk hero(i, north, 1)
    wait for hero(i)
  )
  for(i, 0, 3) do(
    set hero direction(i, i)
  )
  w
  resume caterpillar
end

########################################################################

script, menu tests, begin
  $0="menu tests"
  variable(i, m, mi, main, m1)
  m := create menu, w
  if(get menu id(m) <> -1) then($0="get menu id should have reported -1 for script-generated menu", crash)
  
  mi := add menu item(m), w
  $1="Puppies"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Kittens"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Walruses"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Octopus"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Plip"
  set menu item caption(mi, 1), w

  main := open menu, w
  bring menu forward(bottom menu), w

  for(i, align:left, align:right) do(
    set menu anchor x(m, i), w
    if(get menu anchor x(m) <> i) then($0="menu anchor x", crash)
    set menu anchor y(m, i), w
    if(get menu anchor y(m) <> i) then($0="menu anchor y", crash)
  )

  $1="Puppies"
  mi := find menu item caption(m, 1)
  if(mi == 0) then($0="failed to find first menu item by caption", crash)
  get menu item caption(mi, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not puppies", crash)

  $1="Walruses"
  mi := find menu item caption(m, 1)
  get menu item caption(mi, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not walruses", crash)
  
  mi := find menu item caption(m, 1, mi) #search for Walruses starting after Walruses
  if(mi <> 0) then($0="find menu item walrus should have failed", crash)

  mi := add menu item(m)
  $1="Kittens"
  set menu item caption(mi, 1), w

  variable(kitten1, kitten2, walruses)
  #search for Kitten from top
  $1="Kittens"
  kitten1 := find menu item caption(m, 1)
  #search for Kitten starting after Walruses
  $2="Walruses"
  walruses := find menu item caption(m, 2) 
  kitten2 := find menu item caption(m, 1, walruses) 
  if(kitten1 == 0) then($0="failed to find first kitten", crash)
  if(kitten2 == 0) then($0="failed to find second kitten", crash)
  get menu item caption(kitten1, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not kitten(1)", crash)
  get menu item caption(kitten2, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not kitten(2)", crash)
  if(kitten1 == kitten2) then($0="found the same kitten twice", crash)

  mi := add menu item(m), w
  delete menu item(mi), w
  $1="Kittens"
  mi := find menu item caption(m, 1)
  delete menu item(mi), w
  mi := first menu item(m)
  delete menu item(mi), w

  if(find menu ID(1) <> 0) then($0="found unopened menu", crash)
  open menu(1),w
  m1 := find menu ID(1)
  if(get menu ID(m1) <> 1) then($0="get menu ID mismatch vs find menu", crash)
  if(m1 == 0) then($0="failed to find opened menu", crash)  
  close menu(m1),w

  for(i, -3, 12) do(
    set menu border(main, i), w
  )
  if(get menu border(main) <> 12) then($0="readback of menu border thickness failed", crash)
  for(i, 0, 10) do(
    set menu boxstyle(main, i)
  )
  if(get menu boxstyle(main) <> 10) then($0="readback of menu boxstyle failed", crash)

  for(i, 0, 15) do(
    set menu max chars(main, i), w
    if(get menu max chars(main) <> i) then($0="readback of menu max chars failed", crash)
  )
  set menu max chars(main, 0), w
  for(i, 10, 30) do(
    set menu min chars(main, i), w
    if(get menu min chars(main) <> i) then($0="readback of menu min chars failed", crash)
  )
  set menu min chars(main, 0), w

  for(i, -50, 50, 10) do(
    set menu offset x(main, i), w
    if(get menu offset x(main) <> i) then($0="readback of menu offset x failed", crash)
    set menu offset y(main, i), w
    if(get menu offset y(main) <> i) then($0="readback of menu offset y failed", crash)
  )
  set menu offset x(main, 0)
  set menu offset y(main, 0)
  for(i, align:left, align:right) do(
    set menu anchor x(main, i), w
    if(get menu anchor x(main) <> i) then($0="readback of menu anchor x failed", crash)
    set menu anchor y(main, i), w
    if(get menu anchor y(main) <> i) then($0="readback of menu anchor y failed", crash)
  )
  set menu anchor x(main, 0), w
  set menu anchor y(main, 0), w

  for(i, align:left, align:right) do(
    set menu text align(main, i), w
    if(get menu text align(main) <> i) then($0="readback of menu text align failed", crash)
  )
  set menu text align(main, 0), w

  set menu bit(main, 0, true), w  #Transparent box
  if(get menu bit(main, 0) <> true) then($0="failed to set menu bit", crash)
  set menu bit(main, 0, false), w #Opaque box
  if(get menu bit(main, 0) <> false) then($0="failed to unset menu bit", crash)
  variable(save rows)
  save rows := get menu max rows(main)
  set menu max rows(main, 3), w
  set menu bit(main, 1, true), w  #never show scrollbar
  set menu bit(main, 1, false), w #show scrollbar
  set menu max rows(main, save rows)
  set menu bit(main, 4, true), w  #no box
  set menu bit(main, 4, false), w #show box
  set menu bit(main, 8, true), w  #Advance text box when menu closes
  show text box(6), w
  if(not(menu is open(main))) then($0="why isn't the main menu open?", crash)
  close menu(top menu), w
  close menu(main), w
  if(current text box <> -1) then($0="menu bit failed to close textbox", crash)

  if(menu is open(main)) then($0="why is the main menu still open?", crash)

  variable(antelope, buffalo, catbus, duiker)
  m := create menu, w
  antelope := add menu item(m), $0="Antelope", set menu item caption(antelope, 0), w
  buffalo  := add menu item(m), $0="Buffalo",  set menu item caption(buffalo, 0), w
  catbus   := add menu item(m), $0="Catbus",   set menu item caption(catbus, 0), w
  duiker   := add menu item(m), $0="Duiker",   set menu item caption(duiker, 0), w

  # Hide when disabled 
  set menu item bit(catbus, 0, true), w
  if(get menu item bit(catbus, 0) <> true) then($0="menu item bit readback failed", crash)
  # Disable now
  set menu item type(catbus, menutype:label)
  set menu item subtype(catbus, 1), w
  # Don't hide
  set menu item bit(catbus, 0, false), w
  # Re-enable
  set menu item subtype(catbus, 0), w

  set menu item settag(catbus, 3)
  if(get menu item settag(catbus) <> 3) then($0="menu item settag readback failed", crash)
  if(check tag(3)) then($0="tag 3 shouldn't be on yet (menu)", crash)
  use menu item(catbus), w
  if(not(check tag(3))) then($0="tag 3 shouldn't be on now (menu)", crash)
  set menu item settag(catbus, 0)
  set menu item togtag(catbus, 3)
  use menu item(catbus), w
  if(check tag(3)) then($0="tag 3 should be toggled off (menu)", crash)
  use menu item(catbus), w
  if(check tag(3)==OFF) then($0="tag 3 should be toggled on (menu)", crash)
  use menu item(catbus), w
  if(check tag(3)) then($0="tag 3 should be toggled off again (menu)", crash)
  set menu item togtag(catbus, 0)

  for(i, 1, 2) do(
    set menu item tag(catbus, -3, i), w
    if(get menu item tag(catbus, i) <> -3) then($0="menu item tag readback failed", crash)
    set tag(3, ON), w
    set menu item tag(catbus, 3, i), w
    set tag(3, OFF), w
    set menu item tag(catbus, 0, i), w
  )

  $0="menu item tag req", show string(0)
  for(i, 1, 2) do(
    set tag(3, OFF)
    if(get menu item tag(catbus, i) <> 0) then($0="menu item tag req should be zero:", append number(0, i), crash)
    set menu item tag(catbus, 3, i), w
    if(get menu item tag(catbus, i) <> 3) then($0="menu item tag req readback fail:", append number(0, i), crash)
    set tag(3, ON), w
    set menu item tag(catbus, -3, i), w
    set tag(3, OFF), w
    set menu item tag(catbus, 0, i), w
  )
  show no value
  
  for(i, 0, 2) do(
    set menu item extra(buffalo, i, (i + 1) * 10)
    if(get menu item extra(buffalo, i) <> (i + 1) * 10) then($0="menu item extra readback failed", crash)
  )
  
  set menu item type(catbus, menutype: special)
  $0="" # use default caption
  set menu item caption(catbus, 0), w
  for (i, 0, 13) do(
    set menu item subtype(catbus, i), w
  )
  $0="Catbus, not Save"
  set menu item caption(catbus, 0), w
  $0=""
  set menu item caption(catbus, 0), w
  set menu item type(catbus, menutype:menu), w
  for(i, 0, 2) do(
    set menu item subtype(catbus, i), w
    if(get menu item subtype(catbus) <> i) then($0="menu item subtype readback failed", crash)
  )
  $0="Catbus"
  set menu item caption(catbus, 0), w
  
  # open another menu
  set menu item type(catbus, menutype:menu)
  set menu item subtype(catbus, 2)
  use menu item(catbus), w
  if(get menu id(top menu) <> 2) then($0="Failed to open a menu from a menu", crash)
  close menu(top menu), w

  # open a text box
  set menu item type(catbus, menutype:textbox)
  set menu item subtype(catbus, 7)
  use menu item(catbus), w
  if(current textbox <> 7) then($0="Failed to open a text box from a menu", crash)
  advance text box, w

  if(get menu item type(catbus) <> menutype:textbox) then($0="menu item type readback failed", crash)
  set menu item type(catbus, menutype:label)

  # run a script from a menu
  set menu item type(catbus, menutype:script)
  set menu item subtype(catbus, @on menu item use)
  use menu item(catbus), w
  if(menu item script global <> 99) then($0="Failed to run a script from a menu", crash)

  variable(oldcol)
  oldcol := get menu textcolor(m)
  for(i, 0, 10) do(
    set menu textcolor(m, i * 13), w
    if(get menu textcolor(m) <> i * 13) then($0="menu textcolor readback failed", crash)
  )
  set menu textcolor(m, oldcol)

  # iterate all menu items
  variable(count)
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi)
  )
  if(count <> 4) then($0="iterated wrong number of menu items (all)")
  # now hide catbus
  set menu item bit(catbus, menu item bit:hide when disabled, true)
  set menu item tag(catbus, 3)
  set tag(3, OFF)
  # iterate all except hidden
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi, true)
  )
  if(count <> 3) then($0="iterated wrong number of menu items (vis only)")
  # iterate all including hidden
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi, false)
  )
  if(count <> 4) then($0="iterated wrong number of menu items (vis only)")


  # close when selected
  set menu item bit(antelope, 1, true)
  use menu item(antelope), w
  if(top menu == m) then($0="Even Toed Ungulate menu failed to close", crash)

  menu close global := 0
  m := create menu, w
  mi := add menu item(m)
  $1="close me"
  set menu item caption(mi, 1), w
  set menu item bit(mi, menu item bit:close menu when selected, true)
  set menu on close script(m, @on close menu test)
  if(get menu on close script(m) <> @on close menu test) then($0="menu close script readback failed", crash)
  use menu item(mi), w
  if(menu close global <> 99) then($0="menu close script didn't run", crash)

  menu scroll tests
end

script, on menu item use, begin
  menu item script global := 99
end

script, on close menu test, begin
  menu close global := 99
end


script, scroll through menu, menu, numitems, begin
  variable (i, j, mi)

  # test scrolling
  for (i, 1, 3, 2) do (
    set menu max rows(menu, i)
    # forwards
    mi := first menu item(menu)
    while (mi) do (
      select menu item(mi), w
      mi := next menu item(mi)
    )
    # backwards
    mi := menu item by slot(menu, numitems -- 1)
    while (mi) do (
      select menu item(mi), w
      mi := previous menu item(mi)
    )
    # randomly
    for (j, 0, 4) do (
      select menu item(menu item by slot(menu, random(0, numitems -- 1))), w
    )
  )
  set menu max rows(menu, 0)
end

script, menu scroll tests, begin
  $0="menu scroll tests"

  variable (main, mi, next, i, numitems)
  main := open menu, w
  set menu bit(main, 1, false), w #show scrollbar
  allow minimap(true), w #make sure there are no hidden items
  allow save anywhere(true), w

  # test menu item iteration
  mi := first menu item(main)
  while (mi) do (
    get menuitemcaption(mi,10)
    #trace(10)
    appendnumber(10, numitems)
    assert (menu item slot(mi) == numitems)
    assert (menu item by slot(main, numitems, true) == mi)
    assert (menu item by slot(main, numitems, false) == mi)
    next := next menu item(mi, false)
    if (next) then (
      assert (mi == previous menu item(next))
    )
    set menu item extra(mi, 0, numitems)
    mi := next
    numitems += 1
  )
  $10=""

  # menu item iteration edge cases
  assert (previous menu item(first menu item(main)) == 0)
  assert (next menu item(menu item by slot(main, numitems -- 1)) == 0)
  assert (menu item by slot(main, numitems, true) == 0)
  assert (menu item by slot(main, numitems, false) == 0)
  assert (menu item by slot(main, -1) == 0)

  # test "select menu item"
  mi := first menu item(main)
  while (mi) do (
    select menu item(mi), w
    assert (selected menu item(main) == mi)
    mi := next menu item(mi)
  )

  # test scrolling
  scroll through menu(main, numitems)

  # check hidden items sorted to end:
  # 1. hide three items
  set tag(3, OFF)
  variable(hidden1, hidden2, hidden3)
  hidden3 := menu item by slot(main, 4)
  set menu item bit(hidden3, menu item bit: hide when disabled, true)
  set menu item tag(hidden3, 3, 1)
  hidden1 := menu item by slot(main, 0)
  set menu item bit(hidden1, menu item bit: hide when disabled, true)
  set menu item tag(hidden1, 3, 1)
  hidden2 := menu item by slot(main, 3)
  set menu item bit(hidden2, menu item bit: hide when disabled, true)
  set menu item tag(hidden2, 3, 1)
  w

  # 2. add new item
  mi := add menu item(main)
  set menu item extra(mi, 0, numitems)
  numitems += 1
  $1="a new item!"
  set menu item caption(mi, 1), w

  # 3. check visible items in correct order
  variable (temp, extra, mi2)
  temp := -1
  for (i, 0, num items -- 3 -- 1) do (
    mi := menu item by slot(main, i, true)
    mi2 := menu item by slot(main, i, false)
    assert (mi == mi2)
    extra := get menu item extra(mi2, 0)
    if (extra <= temp) then ($0="menu items not in increasing order", crash)
    temp := extra
  )

  # 4. check hidden items at end in correct order
  if (menu item by slot(main, numitems -- 3, true) <> 0) then ($0="menuitembyslot returned hidden item", crash)
  if (menu item by slot(main, numitems -- 3, false) <> hidden1) then ($0="hidden items out of order", crash)
  if (menu item by slot(main, numitems -- 2, false) <> hidden2) then ($0="hidden items out of order", crash)
  if (menu item by slot(main, numitems -- 1, false) <> hidden3) then ($0="hidden items out of order", crash)
  assert (menu item by slot(main, numitems, false) == 0)

  # test scrolling again
  scroll through menu(main, numitems -- 3)

  # check unhidden menu items sorted back correctly
  set tag(3, ON), w
  for (i, 0, numitems -- 1) do (
    mi := menu item by slot(main, i, false)
    assert (mi == menu item by slot(main, i, true))
    assert (get menu item extra(mi, 0) == i)
  )

  close menu(main)
end

#next menu(menu handle)
#open menu (ID, allow duplicate)
#parent menu(menu item handle)
#previous menu(menu handle)
#swap menu items(handle1, handle2)
#wait for menu (menu handle)

########################################################################

script, textbox tests, begin
  $0="textbox tests"
  show text box(2), w
  advance text box, w
  show text box(3), w
  advance text box, w
  if(current textbox <> 4) then(crash)
  advance text box, w
  show text box(3), w
  advance text box, w
  if(current textbox <> 5) then(crash)
  advance text box, w
  if(current textbox <> -1) then(crash)
end

########################################################################

script, battle tests, begin
  # there are some other battle tests in with the timer tests
  $0="battle tests"
  show value(random(1, 999999999)), w
  force random battle
  show value(random(1, 999999999)), w # this should remain deterministic after battle
  show no value, w
end

script, force random battle, begin
  variable(s, x, y, d)
  # save hero state
  s := get hero speed(me)
  x := hero x(me)
  y := hero y(me)
  d := hero direction(me)
  # get the hero ready for forcing the battle
  set hero speed(0, 20)
  set hero position(0, 15, 9), w
  # force the battle
  walk hero(0, north, 1), w
  # restore hero state
  set hero speed(me, s)
  set hero position(me, x, y)
  set hero direction(me, d)
  w
end

script, force non random battle, begin
  w
  fight formation(0)
  w(2)
end

plotscript, after battle, begin
  $0="After battle script:"
  battle script sequence += 1
  append number(0, battle script sequence)
  trace(0)
  show string at(0, 0, 0)
  w
  hide string(0)
end

plotscript, instead of battle, form, begin
  $0="Instead of battle script("
  append number(0, form)
  $0+")"
  trace(0)
  w
  fight formation(form)
  $0="  finish instead of battle"
  trace(0)
end

########################################################################

script, timer tests, begin
  variable(i)
  
  allocate timers(32)
  set timer(31, 10, 1, @timer test 1, 1)
  show string at(1, 10, 10)
  w, w, w, w
  if(read timer(31) <> 6) then($0="read timer failed", crash)
  w(6), w

  timer global := 100
  set timer(31, 0, 1, @looping timer test, 1)
  w(11)
  
  $10="random"
  test timer and battle interactions(@force random battle)
  $10="fight formation"
  test timer and battle interactions(@force non random battle)
  $10=""

  
  $0="timer interactions with after battle", trace(0)
  teleport to map(1, 10, 8), w # after battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 3) then($0="(ab) afterbattle should have happened 3 times", crash)

  $0="timer interactions with instead of battle", trace(0)
  teleport to map(2, 10, 8), w # instead of battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 0) then($0="(ib) afterbattle should have happened 0 times", crash)

  $0="timer interactions with after battle + instead of battle", trace(0)
  teleport to map(3, 10, 8), w # after battle + instead of battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 3) then($0="(ab+ib) afterbattle should have happened 3 times", crash)

  teleport to map(0, 10, 8), w

  hide string(1)
end

script, test timer and battle interactions, trigger battle, begin
  #regular timer
  timer global := 0
  timer global will become := 1000
  set timer(31, 10, 1, @battle timer test, -1, 0)
  run script by id(trigger battle)
  if(read timer(31) <= 0) then($0="timer should still be running", crash)
  if(timer global <> 0) then($0="timer global should still be zero", crash)
  w(10)
  if(read timer(31) >> 0) then($0="timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="timer global didn't change", crash)
  
  #timerflag:battle
  timer global := 0
  timer global will become := 2000
  set timer(31, 10, 1, @battle timer test, 1, timerflag:battle)
  run script by id(trigger battle)
  if(read timer(31) >> 0) then($0="(bat) timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat) timer global didn't change", crash)

  #timerflag:battle ,or, timerflag:critical
  timer global := 0
  timer global will become := 3000
  set timer(31, 10, 1, @battle timer test, 1, (timerflag:battle,or,timerflag:critical))
  set timer(30, 20, 1, @battle timer test, 0, (timerflag:battle))
  run script by id(trigger battle)
  if(read timer(31) >> 0) then($0="(bat+crit) timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat+crit) timer global didn't change", crash)
  timer global will become := 4000
  if(read timer(30) <= 0) then($0="(bat+crit) second timer should still be running", crash)
  w(12)
  if(read timer(30) >> 0) then($0="(bat+crit) second timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat+crit) timer global didn't change on second timer", crash)
  timer global := 0
  w
end

script, timer test 1, begin
  show value(12345)
  w
end

script, looping timer test, begin
  if(timer global <= 0) then(timer global := 0, exit script)
  set timer(31, 0, 1, @looping timer test, 1)
  timer global -= 10
  show value(timer global)
  _checkpoint
end

script, battle timer test, begin
  timer global := timer global will become
  $0="battle timer test:"
  append number(0, timer global)
  trace(0)
  show string(0), w
end

########################################################################

########################################################################
#### COMMANDS THAT STILL NEED TESTS
#allow minimap (setting)
#allow save anywhere (setting)
#alter NPC (who,NPCstat,value)
#value,and,value
#animation start tile (tile number, layer)
#any key
#append ascii (ID, char)
#append number (ID, number)
#ascii from string (ID, position)
#autonumber
#autosave
#begin,other commands,end
#Boolean Constants
#break
#camera follows hero (who)
#camera follows NPC (who)
#camera pixel X
#camera pixel Y
#cancel key
#cancel map name display
#case(value)
#center slice (handle)
#center string at (ID, x, y)
#change NPC ID (reference,new ID)
#change tileset (tileset, layer)
#check NPC wall (who, direction)
#check parentage (handle, parent handle)
#check tag (tag)
#child count (handle)
#clamp slice (handle1, handle2)
#clear string(ID)
#clone sprite (handle)
#color:blue
#Color Constants
#color:green
#color:red
#concatenate strings (dest, source)
#continue
#copy string (dest, source)
#create container (width, height)
#create ellipse (width, height, border color, fill color)
#create grid (width, height, rows, columns)
#create NPC (ID,X,Y,direction)
#create rect (width, height, style)
#create text
#crop
#current display tile (tile number, layer)
#current map
#current song
#current stat
#days of play
#decrement (variable,amount)
#default tile
#define constant (number,name)
#delete char (ID, position)
#delete enemy from formation (formation, slot)
#delete item (item,number)
#delete map state (whichdata)
#delete save (slot)
#destroy NPC (reference)
#Direction Constants
#dismount vehicle
#number / number
#do
#down
#down key
#draw NPCs above heroes (setting)
#east
#east wall
#eight
#else
#end
#number == number
#exit returning(value)
#exit script
#expand string(ID)
#number ^ power
#export globals (slot, first, last)
#extended scancodes enabled
#extract color(color, component)
#fade screen in
#fade screen out (red,green,blue)
#false
#fight formation (number)
#fill parent (handle, true_or_false)
#find colliding slice (parent, slice, number, check descendants)
#find enemy in formation (formation, enemy id, copy number)
#first child(handle)
#first container child(handle)
#first rect child(handle)
#first sprite child(handle)
#five
#focus camera (x,y,speed)
#for(counter,start,finish,step) do(commands)
#formation probability (formation set, formation)
#formation set frequency (formation set)
#formation slot enemy (formation, slot)
#formation slot x (formation, slot)
#formation slot y (formation, slot)
#four
#free slice (handle)
#free slice children (handle)
#free sprite (handle)
#game over
#get ambient music
#get attack name
#get bottom padding (handle)
#get color(index)
#get count
#get damage cap
#get death script
#get each step script
#get ellipse border col (handle)
#get ellipse fill col (handle)
#get enemy appearance (enemyid, appearance)
#get enemy name (enemyid, stringid)
#get enemy stat(enemy, stat)
#get foot offset
#get formation background (formation, background)
#get formation song (formation)
#get global string (ID, global)
#get grid columns (handle)
#get grid rows (handle)
#get instead of battle script
#get inventory size
#get item (item,number)
#get item name (ID, item)
#get left padding (handle)
#get load script
#get map edge mode
#get map name (ID, map)
#get map tileset
#get money (amount)
#get music volume
#get NPC ID (reference)
#get NPC ignores walls (who)
#get NPC moves (who)
#get NPC obstructs (who)
#get NPC usable (who)
#get on keypress script
#get outline(handle)
#get rect bgcol (handle)
#get rect border (handle)
#get rect fgcol (handle)
#get rect style (handle)
#get rect trans (handle)
#get right padding (handle)
#get slice clipping (handle)
#get slice extra (handle, extra)
#get slice lookup (handle)
#get slice velocity x (handle)
#get slice velocity y (handle)
#get slice visible (handle)
#get song name (ID, song)
#get sort order (handle)
#get sprite frame (handle)
#get sprite palette (handle)
#get sprite set number (handle)
#get sprite trans (handle)
#get sprite type (handle)
#get text bg(handle)
#get text color(handle)
#get tile animation offset (animation pattern, layer)
#get top padding (handle)
#get victory music
#get wrap(handle)
#get zone extra (zone id, extra num)
#get zone name (string id, zone id)
#globals to string(ID, starting global, length)
#global variable (id,name)
#number >> number
#number >= number
#greyscale palette (first, last)
#grid is shown (handle)
#harm tile
#hide battle health meter (state)
#hide battle ready meter (state)
#hide string (ID)
#horiz flip sprite (handle, flip)
#hours of play
#if(condition) then(commands) else(commands)
#import globals (slot, first, last)
#include, filename
#increment (variable,amount)
#init mouse
#input string (ID, maxlength, use current, center, position x, position y)
#inside battle
#inventory (item)
#is filling parent (handle)
#item count in slot (slot)
#item in slot (slot)
#joystick axis (axis,multiplier,joystick)
#joystick button (button,joystick)
#Key Constants
#key is pressed (scancode)
#keyval (scancode)
#last ascii
#last child(handle)
#last formation
#last save slot
#layer tileset (layer)
#leader
#left
#left button
#left key
#number << number
#number <= number
#load attack sprite (num, palette)
#load backdrop sprite (num)
#load border sprite (num, palette)
#load from slot (slot)
#load hero sprite (num, palette)
#load large enemy sprite (num, palette)
#load map state (whichdata, customid)
#load medium enemy sprite (num, palette)
#load palette (palette number)
#load portrait sprite (num, palette)
#load slice collection (id)
#load small enemy sprite (num, palette)
#load tileset (tileset, layer)
#load walkabout sprite (num, palette)
#load weapon sprite (num, palette)
#value && value
#value || value
#value ^^ value
#lookup slice (lookup code, start slice)
#lose money (amount)
#map cure (attack, target, attacker)
#map height (map)
#map width (map)
#maximum stat
#me
#milliseconds
#minutes of play
#number,mod,number
#mouse button (which)
#mouse click (which)
#Mouse Constants
#mouse pixel X
#mouse pixel Y
#mouse region (x min, x max, y min, y max)
#move slice above (handle, above what handle)
#move slice below (handle, below what handle)
#move slice by (handle, relative x, relative y, ticks)
#move slice to (handle, x, y, ticks)
#number * number
#next container sibling(handle)
#next rect sibling(handle)
#next sibling(handle)
#next sprite sibling(handle)
#nine
#none
#north
#north wall
#not (value)
#number <> number
#NPC at pixel (x, y, number)
#NPC at spot (x, y, number)
#NPC copy count (ID)
#NPC direction (who)
#NPC extra (who, which)
#NPC frame (who)
#NPC is walking (who)
#NPC pixel X (who)
#NPC pixel Y (who)
#NPC reference (ID, copy)
#NPC X (who)
#NPC Y (who)
#number from string (ID, default)
#Numeric Constants
#off
#on
#one
#value,or,value
#order menu
#outside battle
#outside battle cure
#overhead tile
#pan camera (direction,distance,pixelstep)
#parent slice (handle)
#party
#party money
#pause sound (num)
#pay money (amount)
#place sprite
#play song (song)
#play sound (num,loop,preempt)
#plotscript, name, argumentnames (statements)
#positionstring (ID, x, y)
#previous sibling(handle)
#put camera (x,y)
#put mouse (X, Y)
#put npc (who,x,y)
#put slice (handle, X, Y)
#put slice screen (handle, x, y)
#put sprite (handle, x, y)
#random (lownumber, highnumber)
#random formation (formation set)
#read attack name (ID, attack)
#read color (index, element)
#read enemy data (enemyid, data)
#read global (id)
#read map block (x,y,layer)
#read NPC (who,NPCstat)
#read pass block (x,y)
#read timer (id)
#read zone (zone id, x, y)
#realign slice (handle, horiz align, vert align, horiz anchor, vert anchor)
#replace attack sprite (handle, num, palette)
#replace backdrop sprite (handle, num)
#replace border sprite (handle, num, palette)
#replace char (ID, position, char)
#replace hero sprite (handle, num, palette)
#replace large enemy sprite (handle, num, palette)
#replace medium enemy sprite (handle, num, palette)
#replace portrait sprite (handle, num, palette)
#replace small enemy sprite (handle, num, palette)
#replace walkabout sprite (handle, num, palette)
#replace weapon sprite (handle, num, palette)
#reset game
#reset map state (whichdata)
#reset palette
#resume box advance
#resume map music
#resume NPCs
#resume NPC walls
#resume obstruction
#resume overlay
#resume player
#resume random enemies
#resume random enemys
#resume timers
#return(value)
#RGB(red, green, blue)
#right
#right button
#right key
#room in active party
#run script by ID (id, argument1, argument2, argument3...)
#save in slot (slot)
#save map state (whichdata, customid)
#save menu (reallysave)
#save slot used (slot)
#script, name, argumentnames (statements)
#search string (ID1, ID2, start)
#seconds of play
#seed random (new seed)
#set ambient music (song)
#set battle wait mode (state)
#set bottom padding (handle, pixels)
#set caterpillar mode (state)
#set color(index, value)
#set damage cap (cap)
#set days of play (days)
#set death script (id)
#set debug keys disable (state)
#set each step script (id)
#set ellipse border col (handle, color)
#set ellipse fill col (handle, color)
#set enemy appearance (enemyid, appearance,value)
#set enemy name (enemyid, stringid)
#set enemy stat(enemy, stat, value)
#set foot offset (offset)
#set formation background (formation, background, animation frames, animation ticks)
#set formation song (formation, song)
#set grid columns (handle, columns)
#set grid rows (handle, rows)
#set harm tile damage (amount)
#set harm tile flash (color)
#set horiz align (handle, edge)
#set horiz anchor (handle, edge)
#set hours of play (hours)
#set inn no revive mode (state)
#set instead of battle script (id)
#set inventory size (new size)
#set item count in slot (slot, count)
#set item in slot (slot, item)
#set left padding (handle, pixels)
#set load script (id)
#set map edge mode (mode, default tile)
#set minutes of play (min)
#set money (amount)
#set music volume (volume)
#set no HP level up restore (state)
#set no MP level up restore (state)
#set NPC direction (who, direction)
#set NPC extra (who, which, value)
#set NPC frame (who, frame)
#set NPC ignores walls (who, value)
#set NPC moves (who, value)
#set NPC obstructs (who, value)
#set NPC position (who, X, Y)
#set NPC speed (who, speed)
#set NPC usable (who, value)
#set on keypress script (id)
#set outline(handle, outline)
#set padding (handle, pixels)
#set parent (handle, parent handle)
#set rect bgcol (handle, color)
#set rect border (handle, border)
#set rect fgcol (handle, color)
#set rect style (handle, style)
#set rect trans (handle, transparency setting)
#set right padding (handle, pixels)
#set seconds of play (sec)
#set slice clipping (handle, clip)
#set slice edge x (handle, edge, value)
#set slice edge y (handle, edge, value)
#set slice extra (handle, extra, value)
#set slice height (handle, height)
#set slice lookup (handle, code)
#set slice screen x (handle, x)
#set slice screen y (handle, y)
#set slice text(handle, string id)
#set slice velocity (handle, horiz pixels per tick, vert pixels per tick, ticks)
#set slice velocity x (handle, pixels per tick, ticks)
#set slice velocity y (handle, pixels per tick, ticks)
#set slice visible (handle, vis)
#set slice width (handle, width)
#set slice x (handle, X)
#set slice y (handle, Y)
#set sort order (handle, order)
#set sprite frame (handle, num)
#set sprite palette (handle, num)
#set sprite trans (handle, drawtransparent)
#set sprite visible
#set tag (tag,value)
#set text bg(handle, color)
#set text color(handle, color)
#set tile animation offset (animation pattern, offset, layer)
#set timer (id, count, speed, trigger, string, flags)
#set top padding (handle, pixels)
#variable := value
#set vert align (handle, edge)
#set vert anchor (handle, edge)
#set victory music (song)
#set wrap(handle, wrap)
#set zone extra (zone id, extra num, value)
#seven
#show backdrop (number)
#show grid (handle, shown)
#show map
#show mini map
#show no value
#show string (ID)
#show string at (ID, x, y)
#show value (number)
#sign (number)
#six
#slice at pixel (parent, x, y, number, check descendants)
#slice child (handle, number)
#slice collide (handle1, handle2)
#slice collide point (handle, x, y)
#slice contains (handle1, handle2)
#slice edge x (handle, edge)
#slice edge y (handle, edge)
#slice height (handle)
#slice is container (handle)
#slice is ellipse (handle)
#slice is grid (handle)
#slice is moving (handle)
#slice is rect (handle)
#slice is sprite (handle)
#slice is text (handle)
#slice is valid (id)
#slice screen x (handle)
#slice screen y (handle)
#slice to back (handle)
#slice to front (handle)
#slice width (handle)
#slice x (handle)
#slice y (handle)
#song: same as last map
#song: same as map
#song: silence
#sort children (handle, wipe)
#sound is playing (num)
#south
#south wall
#spells menu (who)
#sprite frame count (handle)
#sprite is horiz flipped (handle)
#sprite is vert flipped (handle)
#sprite layer
#sqrt (number)
#status screen (who)
#stop slice (handle)
#stop song
#stop sound (num)
#stop timer (id)
#string color (ID, foreground color, background color)
#string compare (ID1, ID2)
#string from textbox (ID, textbox, line, expand)
#string is visible (ID)
#string length (ID)
#string style (ID, style)
#string to globals (ID, starting global, length)
#string X (ID)
#string Y (ID)
#number -- number
#suspend box advance
#suspend catapillar
#suspend caterpillar
#suspend map music
#suspend NPCs
#suspend NPC walls
#suspend obstruction
#suspend overlay
#suspend player
#suspend random enemies
#suspend random enemys
#suspend timers
#swap by name (name,name)
#swap by position (position,position)
#switch(expression)
#system day
#system hour
#system minute
#system month
#system second
#system year
#team menu
#teleport to map (map, x, y)
#nine
#then
#three
#Tile Constants
#timer: default
#timer flag: battle
#timer flag: critical
#timer flag: menu
#timer: game over
#trace (string)
#trace value (expression, ...)
#trim string (ID, start, length)
#true
#tweak palette (red, green, blue, first, last)
#two
#up
#update palette
#up key
#use door (number)
#use item (item)
#use item in slot(slot)
#use key
#use NPC (who)
#use shop (shop)
#variable (name)
#vehicle A
#vehicle B
#vert flip sprite (handle, flip)
#wait (ticks)
#wait for all
#wait for camera
#wait for key (key)
#wait for NPC (who)
#wait for scancode (key)
#wait for slice (handle)
#wait for text box
#walk NPC (who, direction, distance)
#walk NPC to X (who, X)
#walk NPC to Y (who, Y)
#west
#west wall
#while(condition) do(commands)
#wrap
#write color (index, element, value)
#write enemy data (enemyid, data, value)
#write global (id,value)
#write map block (x,y,value,layer)
#write pass block (x,y,value)
#write zone (zone id, x, y, value)
#x axis
#value,xor,value
#y axis
#Y sort children (handle)
#zero
#zone at spot (x, y, count)
#zone number of tiles (zone id)
#add enemy to formation (formation, enemy id, x, y, slot)

########################################################################
### INTERACTIVE COMMANDS THAT THIS SCRIPT MAKES NO ATTEMPT TO TEST
#
#equip menu (who)
#items menu
#load menu (reallyload)
#main menu
#pick hero
#rename hero(who)
#rename hero by slot(who)
#set full hero swap mode (state)
